// Professional Gear Generator
// Creates gears with proper involute tooth profiles and configurable parameters

note {
  Professional Gear Generator
  Creates gears with proper involute tooth profiles and configurable parameters
  Demonstrates: Advanced gear design with involute curves and tool compensation
  Author: GGcode Examples
  Version: 1.0
}

// ── G-code File Variables ──
let id = 4453            // File ID
let nline = 1            // Line numbering: 1 = enabled, 0 = disabled
let decimalpoint = 3     // Number of decimal places (range: 0–6)


// === Configurable Parameters ===
let center_x = 0 /// @number -50 50 // Center X coordinate
let center_y = 0 /// @number -50 50 // Center Y coordinate
let teeth_count = 64 /// @number 8 128 // Number of teeth
let module_size = 1.5 /// @number 0.5 5 // Module size (tooth size)
let pressure_angle_deg = 10 /// @number 14.5 25 // Pressure angle (degrees)
let feed_rate = 150 /// @number 50 300 // Feed rate in mm/min
let z_depth = -0.2 /// @number -5 0 // Z cutting depth
let z_safe = 1 /// @number 1 5 // Safe Z height

let passes = 40 /// @number 1 1000 // Number of depth passes

let flank_steps = 20 /// @number 10 50 // Steps per tooth flank
let arc_steps = 17 /// @number 10 30 // Steps per root arc

// === Calculated Gear Dimensions ===
let pressure_angle = pressure_angle_deg * DEG_TO_RAD
let pitch_radius = (module_size * teeth_count) / 2
let base_radius = pitch_radius * cos(pressure_angle)
let addendum = module_size
let dedendum = 1.25 * module_size
let outer_radius = pitch_radius + addendum
let root_radius = pitch_radius - dedendum

// === Cut shaft hole first (simple circle with G1) ===
let shaft_radius = 40 /// @number 1 300 // shaft radius 
let shaft_steps = 100 

// === Move to safe height and center ===
G0 Z[z_safe]
G0 X[center_x] Y[center_y]
G0 X[center_x + shaft_radius] Y[center_y]


for pass = 0..passes {
    let current_z = z_depth * pass
for i = 0..shaft_steps {
    let angle = 2 * PI * i / shaft_steps
    let x = center_x + shaft_radius * cos(angle)
    let y = center_y + shaft_radius * sin(angle)
    
    if i == 0 {
        G0 X[x] Y[y]
        G0 Z[current_z] F[feed_rate]
    } else {
        G1 Z[current_z] X[x] Y[y] F[feed_rate]
    }
}
}

G0 Z[z_safe]




    let start = 0
// === Generate Gear Teeth with Multiple Passes ===
for pass = 0..passes {
    let current_z = z_depth * (pass)
    // Generate teeth for this pass
    for tooth_index = 0..teeth_count -1 {
        let center_angle = 2 * PI / teeth_count
        let half_tooth_angle = center_angle / 2
        let center_rad = tooth_index * center_angle
        
        // Determine if this tooth should be drawn (alternating pattern)
        let draw_tooth = (tooth_index - floor(tooth_index / 2) * 2) == 0
        let next_draw = ((tooth_index + 1) - floor((tooth_index + 1) / 2) * 2) == 0
        
        if (draw_tooth) {
            // === Left Flank (Involute Curve) ===
            let flank_left_start_t = 0
            let flank_left_end_t = sqrt(outer_radius * outer_radius - base_radius * base_radius) / base_radius * 0.97
            
            // Start point of left flank
            let t0 = flank_left_start_t
            let x0 = base_radius * (cos(t0) + t0 * sin(t0))
            let y0 = base_radius * (sin(t0) - t0 * cos(t0))
            let rot = center_rad - half_tooth_angle
            let x_start = center_x + x0 * cos(rot) - y0 * sin(rot)
            let y_start = center_y + x0 * sin(rot) + y0 * cos(rot)
            
if start == 0 {
            G0 X[x_start] Y[y_start]
            start = 1
let root_x_start = x_start
let root_y_start = y_start
}
            // Move to tooth start
            G1 X[x_start] Y[y_start]
            G1 Z[current_z] F[feed_rate]

            // Generate left flank points
            for i = 0..flank_steps {
                let t = flank_left_start_t + (flank_left_end_t - flank_left_start_t) * i / flank_steps
                let x = base_radius * (cos(t) + t * sin(t))
                let y = base_radius * (sin(t) - t * cos(t))
                let x_rot = center_x + x * cos(rot) - y * sin(rot)
                let y_rot = center_y + x * sin(rot) + y * cos(rot)
                G1 X[x_rot] Y[y_rot] F[feed_rate]
            }
            
            // === Right Flank (Mirrored Involute) ===
            for i = flank_steps..0 step -1 {
                let t = flank_left_start_t + (flank_left_end_t - flank_left_start_t) * i / flank_steps
                let x = base_radius * (cos(t) + t * sin(t))
                let y = -1 * (base_radius * (sin(t) - t * cos(t)))  // mirror Y
                let angle_mirror = center_rad + half_tooth_angle
                let x_rot = center_x + x * cos(angle_mirror) - y * sin(angle_mirror)
                let y_rot = center_y + x * sin(angle_mirror) + y * cos(angle_mirror)
                G1 X[x_rot] Y[y_rot] F[feed_rate]
            }
            
            // === Draw Root Arc (if next tooth is not drawn) ===
            if (!next_draw) {
                let arc_start_angle = center_rad + half_tooth_angle
                let arc_end_angle = center_rad + center_angle + half_tooth_angle

                for j = 0..arc_steps {
                    let a = arc_start_angle + (arc_end_angle - arc_start_angle) * j / arc_steps
                    let x_arc = center_x + root_radius * cos(a)
                    let y_arc = center_y + root_radius * sin(a)
                    G1 X[x_arc] Y[y_arc] F[feed_rate]
                }
            }
        }
    }
   G1 X[root_x_start] Y[root_y_start]
}


// === Return to safe height and center ===
G0 Z[z_safe]
G0 X[center_x] Y[center_y]
