// Crop Circle Pattern Example
// Creates a crop circle-like pattern using alternating G2/G3 arc segments

note {
  Crop Circle Pattern Example
  Creates a crop circle-like pattern using alternating G2/G3 arc segments
  Demonstrates: Alternating arc directions for unique geometric patterns
  Author: GGcode Examples
  Version: 1.0
}

// ── G-code File Variables ──
let id = 4453            // File ID
let nline = 1            // Line numbering: 1 = enabled, 0 = disabled
let decimalpoint = 3     // Number of decimal places (range: 0–6)


// Configurable parameters
let center_x = 0 /// @number -50 50 // Center X coordinate
let center_y = 0 /// @number -50 50 // Center Y coordinate
let feed_rate = 150 /// @number 50 300 // Feed rate in mm/min
let z_depth = -1 /// @number -5 0 // Z cutting depth
let z_safe = 2 /// @number 1 5 // Safe Z height
let start_radius = 6 /// @number 3 12 // Pattern start radius
let max_radius = 20 /// @number 10 30 // Pattern max radius
let revolutions = 1.5 /// @number 0.5 3 // Pattern revolutions
let segment_angle = 20 /// @number 10 45 // Segment angle in degrees

// Move to safe height and starting position
G0 Z[z_safe]
G0 X[center_x + start_radius] Y[center_y]
G1 Z[z_depth] F[feed_rate]

let current_radius = start_radius
let total_angle = revolutions * 360
let total_segments = total_angle / segment_angle
let radius_step = (max_radius - start_radius) / total_segments

// Draw crop circle pattern using alternating G2/G3 arc segments
for i = 0..total_segments {
    let current_angle = i * segment_angle * DEG_TO_RAD
    let next_angle = (i + 1) * segment_angle * DEG_TO_RAD
    let next_radius = current_radius + radius_step
    
    // Calculate start and end points for this arc segment
    let start_x = center_x + current_radius * cos(current_angle)
    let start_y = center_y + current_radius * sin(current_angle)
    let end_x = center_x + next_radius * cos(next_angle)
    let end_y = center_y + next_radius * sin(next_angle)
    
    // Alternate between G2 (clockwise) and G3 (counter-clockwise)
    if (mod(i, 2) == 0) {
        // Use G2 for clockwise arc segment
        G2 X[end_x] Y[end_y] R[current_radius] F[feed_rate]
    } else {
        // Use G3 for counter-clockwise arc segment
        G3 X[end_x] Y[end_y] R[current_radius] F[feed_rate]
    }
    
    current_radius = next_radius
}

// Move to safe height and return to center
G0 Z[z_safe]
G0 X[center_x] Y[center_y] 