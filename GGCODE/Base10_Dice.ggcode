// Base10 Dice Example
// Creates dice representations for each digit 0-9 using standard pip patterns

note {
  Base10 Dice Example
  Creates dice representations for digits 0-9 using standard pip patterns
  Demonstrates: Digit visualization with pip arrays
  Author: T1
  Version: 1.2
}

// ── G-code File Variables ──
let id = 5002
let nline = 1
let decimalpoint = 4

// ── Configurable parameters ──
let safe_z = 1 /// @number 1 5 // Safe retract height
let size = 10 /// @number 5 20 // Die size
let corner_radius = 2 /// @number 0 10 // corner radius
let pip_radius = 1/// @number 0 100 // pip radius
let space = 2 /// @number 1 5 // Spacing between dice
let printme = 134411220 /// @number 0 9999999999// Number to draw

// Rounded square with corner arcs
function draw_rounded_square(size, radius,center_x,center_y) {
    let half = size / 2
    let r = radius
    let steps = 6  // segments per quarter-circle

    // Corner centers
    let bl_x = center_x - half + r
    let bl_y = center_y - half + r
    let br_x = center_x + half - r
    let br_y = center_y - half + r
    let tr_x = center_x + half - r
    let tr_y = center_y + half - r
    let tl_x = center_x - half + r
    let tl_y = center_y + half - r

    // Start at bottom-left edge start
    G0 Z[safe_z] X[bl_x] Y[center_y - half]
    G0 Z[0]

    // Bottom edge
    G1 X[br_x] Y[center_y - half]

    // Bottom-right corner (clockwise)
    for i = 0..steps {
        let angle = (270 + i * 90 / steps) * DEG_TO_RAD
        let x = br_x + r * cos(angle)
        let y = br_y + r * sin(angle)
        G1 X[x] Y[y]
    }

    // Right edge
    G1 X[center_x + half] Y[tr_y]

    // Top-right corner
    for i = 0..steps {
        let angle = (0 + i * 90 / steps) * DEG_TO_RAD
        let x = tr_x + r * cos(angle)
        let y = tr_y + r * sin(angle)
        G1 X[x] Y[y]
    }

    // Top edge
    G1 X[tl_x] Y[center_y + half]

    // Top-left corner
    for i = 0..steps {
        let angle = (90 + i * 90 / steps) * DEG_TO_RAD
        let x = tl_x + r * cos(angle)
        let y = tl_y + r * sin(angle)
        G1 X[x] Y[y]
    }

    // Left edge
    G1 X[center_x - half] Y[bl_y]

    // Bottom-left corner
    for i = 0..steps {
        let angle = (180 + i * 90 / steps) * DEG_TO_RAD
        let x = bl_x + r * cos(angle)
        let y = bl_y + r * sin(angle)
        G1 X[x] Y[y]
    }

    G0 Z[safe_z]
}

function draw_pip(px, py, radius,center_x,center_y) {
    let steps = 2*size
    for i = 0..steps {
        let angle = (i * 360 / steps) * DEG_TO_RAD
        let x = center_x + px + radius * cos(angle)
        let y = center_y + py + radius * sin(angle)
        if i == 0 {
            G0 Z[safe_z] X[x] Y[y]
            G0 Z[0]
        } else {
            G1 X[x] Y[y]
        }
    }
    G0 Z[safe_z]
}

// ── Main Print Function ──
function print(num, size,center_x,center_y) {
    let str = num
    // Count digits
    let temp = str
    let count = 0
    while temp > 0 {
        temp = floor(temp / 10)
        count = count + 1
    }

    let newcount = count-1
    // Extract digits left → right
    for i = 0..count-1 {
        let divisor = pow(10, newcount)
        let digit = floor(str / divisor)
        digit = digit - floor(digit / 10) * 10   // simulate % 10

        // Compute die center for this digit
        let die_center_x = center_x + (count - newcount - 1) * (size + space)
        let die_center_y = center_y
        note { printing die [digit] at X[die_center_x] Y[die_center_y] }

        // ── Dice Digits ──
        let half = size/2
        let offset = pip_radius*3   // grid spacing
        let r = pip_radius          // pip radius

        // Draw square border at correct die center
        draw_rounded_square(size, corner_radius, die_center_x, die_center_y)

        // Center pip
        if digit == 1 || digit == 3 || digit == 5 || digit == 7 || digit == 9 {
            draw_pip(0, 0, r, die_center_x, die_center_y)
        }

        // Opposite corners for 2,3,4,5,6,7,8,9
        if digit >= 2 {
            draw_pip(-offset, -offset, r, die_center_x, die_center_y)
            draw_pip(offset, offset, r, die_center_x, die_center_y)
        }
        if digit >= 4 {
            draw_pip(-offset, offset, r, die_center_x, die_center_y)
            draw_pip(offset, -offset, r, die_center_x, die_center_y)
        }
        if digit >= 6 {
            draw_pip(-offset, 0, r, die_center_x, die_center_y)
            draw_pip(offset, 0, r, die_center_x, die_center_y)
        }
        if digit >= 8 {
            draw_pip(0, offset, r, die_center_x, die_center_y)
            draw_pip(0, -offset, r, die_center_x, die_center_y)
        }

        newcount = newcount-1
    }
}

for w = 1..50 {
   for i = 0..9 {
     print(i+w, size,w*12,i*12)
     }
}

// Return to origin
let center_x = 0
let center_y = 0
G0 X[center_x] Y[center_y] Z[safe_z]
