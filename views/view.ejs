
<style>
* {
  box-sizing: border-box;
}

#gcodeViewerModal {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#gcodeViewerContainer {
  overflow: hidden;
  overflow-y: auto;
  width: 100vw;
  height: 100vh;
  background: #1d1d1d79;
  border-radius: 8px;
  box-shadow: 5 5 32px #0000004b;
  backdrop-filter: blur(0px);
  -webkit-backdrop-filter: blur(0px);
}

.sim-controls-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 10px 0 10px;
}

.sim-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: none;
  background: #222;
  color: #fff;
  transition: background 0.2s;
  cursor: pointer;
  padding: 0;
}

.sim-btn svg {
  width: 18px;
  height: 18px;
}

.sim-play { background: #2ecc4096; }
.sim-pause { background: #ffdd0096; }
.sim-stop { background: #ff3d36; }
.sim-exit { background: #00000023; margin-left: auto; }
.sim-btn:hover { filter: brightness(1.2); }

.sim-speed-label {
  color: #fff;
  margin-left: 20px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.gcode-line-info {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #ffdc00;
  font-size: 1.1em;
  padding: 4px 16px;
  z-index: 30;
  font-family: 'Consolas', 'Monaco', monospace;
  max-width: 90vw;
  white-space: pre;
  text-align: center;
}

@media (max-width: 480px) {
  .sim-controls-bar {
    flex-direction: column;
    align-items: stretch;
    gap: 4px;
    padding: 8px;
  }

  .sim-speed-label {
    flex-direction: column;
    align-items: flex-start;
    font-size: 0.9em;
  }

  #simSpeedSlider {
    width: 100% !important;
  }

  #simProgressBar {
    bottom: 80px;
  }
}
</style>


<div id="gcodeViewerModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0, 0, 0, 0.548); z-index:2000; align-items:center; justify-content:center;">
  
  
  <div id="gcodeViewerContainer" class="gcodeViewerContainer">

  <div id="gcodeViewerStats" class="gcodeViewerStats" style="position:absolute; top:40px; left:10px; z-index:10;">

</div>

        <div class="sim-controls-bar" style="position:absolute; top:0px; right:0px; z-index:10;"  >
            <button onclick="closeGcodeViewer()" title="Exit" class="sim-btn sim-exit">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 2L14 14M14 2L2 14" stroke="#fff" stroke-width="2" stroke-linecap="round"/></svg>
              </button>
        </div>

        <!-- Only keep the new controls bar and the 3D view area -->
    <div class="sim-controls-bar" style="position:absolute; bottom:10px; left:10px; width:calc(100% - 20px); z-index:10;"  >
      <button id="runSimulationBtn" title="Play" class="sim-btn sim-play">
        <svg id="runSimulationIcon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><polygon points="4,2 14,8 4,14" fill="#fff"/></svg>
      </button>
      <button id="rewindSimulationBtn" title="Rewind" class="sim-btn sim-rewind">
        <svg id="rewindSimulationIcon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><polygon points="12,2 2,8 12,14" fill="#fff"/></svg>
      </button>
      <button id="forwardSimulationBtn" title="Forward" class="sim-btn sim-forward">
        <svg id="forwardSimulationIcon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><polygon points="4,2 14,8 4,14" fill="#fff"/><polygon points="8,2 18,8 8,14" fill="#fff"/></svg>
      </button>
      <label class="sim-speed-label">
        <span>Speed:</span>
        <input id="simSpeedSlider" type="range" min="0.001" max="10" value="10" step="0.1" style="vertical-align:middle; width:300px;">
        <span id="simSpeedValue">50</span> <span id="simSpeedUnit">ms/step</span>
      </label>
    </div>
    <input id="simProgressBar" type="range" min="0" max="1000" value="0" step="1" style="position:absolute; bottom:40px; left:10px; width:calc(100% - 20px); z-index:10;">
    <div id="gcode3d" style="width:100%; height:100%;"></div>
    <div id="gcodeLineInfo" class="gcode-line-info" style="display:none;"></div>
  </div>

</div>




<script>

// Add these at the very top of the file, before any other code
const ARROW_LENGTH = 1;
const ARROW_HEAD_LENGTH = 0.2;
const ARROW_HEAD_WIDTH = 0.1;

// --- PERFORMANCE OPTIMIZATION CONSTANTS ---
const GCODE_REGEX = {
  G_MODE: /G([0123])/g,
  X_COORD: /X(-?\d*\.?\d+)/i,
  Y_COORD: /Y(-?\d*\.?\d+)/i,
  Z_COORD: /Z(-?\d*\.?\d+)/i,
  I_OFFSET: /I(-?\d*\.?\d+)/i,
  J_OFFSET: /J(-?\d*\.?\d+)/i,
  R_RADIUS: /R(-?\d*\.?\d+)/i,
  HAS_COORDS: /[XYZIJR]/i,
  N_LINE: /^N\d+\s*/
};

// --- BATCHED LINE RENDERING OPTIMIZATION ---
// Store these globally for simulation - initialize all G-code modes at once
window.gcodeBatchedLines = { G0: null, G1: null, G2: null, G3: null };
window.gcodeBatchedGeometries = { G0: null, G1: null, G2: null, G3: null };
window.gcodeBatchedCounts = { G0: 0, G1: 0, G2: 0, G3: 0 };

let simState = { playing: false, paused: false, stopped: true, idx: 0 };

// --- DOM ELEMENT CACHE ---
let domElements = {};

function cacheDOMElements() {
  domElements = {
    playBtn: document.getElementById('runSimulationBtn'),
    rewindBtn: document.getElementById('rewindSimulationBtn'),
    forwardBtn: document.getElementById('forwardSimulationBtn'),
    runSimulationIcon: document.getElementById('runSimulationIcon'),
    progressBar: document.getElementById('simProgressBar'),
    speedSlider: document.getElementById('simSpeedSlider'),
    speedValue: document.getElementById('simSpeedValue'),
    speedUnit: document.getElementById('simSpeedUnit'),
    gcodeLineInfo: document.getElementById('gcodeLineInfo'),
    gcode3d: document.getElementById('gcode3d'),
    gcodeViewerModal: document.getElementById('gcodeViewerModal')
  };
}

// --- UI CONSTANTS ---
const playIcon = '<polygon points="4,2 14,8 4,14" fill="#fff"/>';
const pauseIcon = '<rect x="3" y="2" width="3" height="12" fill="#fff"/><rect x="10" y="2" width="3" height="12" fill="#fff"/>';

// --- PERFORMANCE MONITORING ---
let performanceStats = {
  parseTime: 0,
  renderTime: 0,
  segmentCount: 0,
  lineCount: 0
};

// --- ERROR HANDLING ---
function showError(message, duration = 5000) {
  const errorDiv = document.createElement('div');
  errorDiv.style.cssText = `
    position: fixed; top: 20px; right: 20px; 
    background: #ff4444; color: white; padding: 10px 15px; 
    border-radius: 5px; z-index: 10000; font-family: monospace;
    max-width: 400px; word-wrap: break-word;
  `;
  errorDiv.textContent = message;
  document.body.appendChild(errorDiv);
  setTimeout(() => errorDiv.remove(), duration);
}

// --- LOADING INDICATOR ---
function showLoadingIndicator(show = true) {
  let loader = document.getElementById('gcodeLoader'); // This is fine - it's for a dynamic element
  if (show && !loader) {
    loader = document.createElement('div');
    loader.id = 'gcodeLoader';
    loader.style.cssText = `
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.8); color: white; padding: 20px;
      border-radius: 10px; z-index: 10000; font-family: monospace;
    `;
    loader.innerHTML = 'Processing G-code...<br><small>Please wait</small>';
    document.body.appendChild(loader);
  } else if (!show && loader) {
    loader.remove();
  }
}



// --- PERFORMANCE DISPLAY ---
function showPerformanceStats() {
  if (performanceStats.segmentCount === 0) return;
  
  const statsContainer = document.getElementById('gcodeViewerStats');
  console
  if (!statsContainer) return;
  

  
  // Clear existing content and add stats
  statsContainer.innerHTML = `
    <div style="color: #00ff00; padding: 10px 15px; border-radius: 5px; font-family: monospace; font-size: 14px; max-width: 300px;">
      Parse: ${performanceStats.parseTime.toFixed(1)}ms<br>
      Render: ${performanceStats.renderTime.toFixed(1)}ms<br>
      Lines: ${performanceStats.lineCount}<br>
      Segments: ${performanceStats.segmentCount}<br>
      <div style="color: #FF8E37;">G0: ${window.gcodeSegmentCounts?.G0 || 0}</div>
      <div style="color: #00ff99;">G1: ${window.gcodeSegmentCounts?.G1 || 0}</div>
      <div style="color: #0074D9;">G2: ${window.gcodeSegmentCounts?.G2 || 0}</div>
      <div style="color: #F012BE;">G3: ${window.gcodeSegmentCounts?.G3 || 0}</div>

    </div>
  `;
}

// Create tool arrow helper
function createToolArrow(scene, position = new THREE.Vector3(0, 0, 0)) {
  const arrowColor = 0xffff00;
  const arrowDir = new THREE.Vector3(0, 0, -1); // always down from top
  const arrowPos = position.clone().add(new THREE.Vector3(0, 0, ARROW_LENGTH));
  const tool = new THREE.ArrowHelper(arrowDir, arrowPos, ARROW_LENGTH, arrowColor, ARROW_HEAD_LENGTH, ARROW_HEAD_WIDTH);
  scene.add(tool);
  return tool;
}

// Update all draw ranges for G0/G1/G2/G3 geometries
function updateAllDrawRanges(g1Segs = 0, g0Segs = 0, g2Segs = 0, g3Segs = 0) {
  if (window.gcodeBatchedGeometries.G1)
    window.gcodeBatchedGeometries.G1.setDrawRange(0, g1Segs * 2);
  if (window.gcodeBatchedGeometries.G0)
    window.gcodeBatchedGeometries.G0.setDrawRange(0, g0Segs * 2);
  if (window.gcodeBatchedGeometries.G2)
    window.gcodeBatchedGeometries.G2.setDrawRange(0, g2Segs * 2);
  if (window.gcodeBatchedGeometries.G3)
    window.gcodeBatchedGeometries.G3.setDrawRange(0, g3Segs * 2);
}

// Update tool position and direction
function updateToolPosition(tool, position) {
  if (tool && typeof tool.position === 'object') {
    tool.position.copy(position).add(new THREE.Vector3(0, 0, ARROW_LENGTH));
  }
  if (tool && typeof tool.setDirection === 'function') {
    tool.setDirection(new THREE.Vector3(0, 0, -1));
  }
}

// Update progress bar value safely
function updateProgressBar(value) {
  if (domElements.progressBar) {
    domElements.progressBar.value = value;
  }
}

// Setup OrbitControls with consistent settings
function setupOrbitControls(camera, renderer, render) {
  let controls;
  if (THREE.OrbitControls) {
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.mouseButtons = {
      LEFT: THREE.MOUSE.PAN,
      MIDDLE: THREE.MOUSE.ROTATE,
      RIGHT: THREE.MOUSE.PAN
    };
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;
    controls.screenSpacePanning = true;
    controls.enableDamping = false;
    controls.dampingFactor = 0.05;
    controls.addEventListener('change', render);
  } else if (window.OrbitControls) {
    controls = new window.OrbitControls(camera, renderer.domElement);
    controls.mouseButtons = {
      LEFT: window.THREE.MOUSE.PAN,
      MIDDLE: window.THREE.MOUSE.ROTATE,
      RIGHT: window.THREE.MOUSE.PAN
    };
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;
    controls.screenSpacePanning = true;
    controls.enableDamping = false;
    controls.dampingFactor = 0.05;
    controls.addEventListener('change', render);
  }
  return controls;
}

// Dispose of old geometries and materials
function disposeOldGeometries() {
  if (window.gcodeBatchedGeometries && window.gcodeBatchedGeometries.G1) window.gcodeBatchedGeometries.G1.dispose();
  if (window.gcodeBatchedGeometries && window.gcodeBatchedGeometries.G0) window.gcodeBatchedGeometries.G0.dispose();
  if (window.gcodeBatchedGeometries && window.gcodeBatchedGeometries.G2) window.gcodeBatchedGeometries.G2.dispose();
  if (window.gcodeBatchedGeometries && window.gcodeBatchedGeometries.G3) window.gcodeBatchedGeometries.G3.dispose();
  if (window.gcodeBatchedLines && window.gcodeBatchedLines.G1 && window.gcodeBatchedLines.G1.material) window.gcodeBatchedLines.G1.material.dispose();
  if (window.gcodeBatchedLines && window.gcodeBatchedLines.G0 && window.gcodeBatchedLines.G0.material) window.gcodeBatchedLines.G0.material.dispose();
  if (window.gcodeBatchedLines && window.gcodeBatchedLines.G2 && window.gcodeBatchedLines.G2.material) window.gcodeBatchedLines.G2.material.dispose();
  if (window.gcodeBatchedLines && window.gcodeBatchedLines.G3 && window.gcodeBatchedLines.G3.material) window.gcodeBatchedLines.G3.material.dispose();
}

// Create line objects for all G-code modes
function createLineObjects(scene, g0Points, g1Points, g2Points, g3Points) {
  function makeLine(points, color, opacity) {
    if (points.length === 0) return null;
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    geometry.setDrawRange(0, 0); // Start hidden
    const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
    const line = new THREE.LineSegments(geometry, material);
    return { line, geometry };
  }

  // CNC-standard colors
  const g0Obj = makeLine(g0Points, 0xFF8E37, 0.6);    // Orange (rapid)
  const g1Obj = makeLine(g1Points, 0x00ff99, 0.9);    // Green (linear)
  const g2Obj = makeLine(g2Points, 0x0074D9, 0.9);    // Blue (CW arc)
  const g3Obj = makeLine(g3Points, 0xF012BE, 0.9);    // Magenta (CCW arc)

  // Add to scene and store references
  if (g0Obj) {
    scene.add(g0Obj.line);
    window.gcodeBatchedLines.G0 = g0Obj.line;
    window.gcodeBatchedGeometries.G0 = g0Obj.geometry;
    window.gcodeBatchedCounts.G0 = g0Points.length;
    g0Obj.geometry.setDrawRange(0, g0Points.length);
  }
  if (g1Obj) {
    scene.add(g1Obj.line);
    window.gcodeBatchedLines.G1 = g1Obj.line;
    window.gcodeBatchedGeometries.G1 = g1Obj.geometry;
    window.gcodeBatchedCounts.G1 = g1Points.length;
    g1Obj.geometry.setDrawRange(0, g1Points.length);
  }
  if (g2Obj) {
    scene.add(g2Obj.line);
    window.gcodeBatchedLines.G2 = g2Obj.line;
    window.gcodeBatchedGeometries.G2 = g2Obj.geometry;
    window.gcodeBatchedCounts.G2 = g2Points.length;
    g2Obj.geometry.setDrawRange(0, g2Points.length);
  }
  if (g3Obj) {
    scene.add(g3Obj.line);
    window.gcodeBatchedLines.G3 = g3Obj.line;
    window.gcodeBatchedGeometries.G3 = g3Obj.geometry;
    window.gcodeBatchedCounts.G3 = g3Points.length;
    g3Obj.geometry.setDrawRange(0, g3Points.length);
  }
}

// --- HELPER FUNCTIONS ---

// Helper: Interpolate arc points for G2/G3
function interpolateArc(start, end, center, isClockwise, segments = 32) {
  const points = [];
  const radius = Math.sqrt((start.x - center.x) ** 2 + (start.y - center.y) ** 2);
  const startAngle = Math.atan2(start.y - center.y, start.x - center.x);
  const endAngle = Math.atan2(end.y - center.y, end.x - center.x);
  let deltaAngle = endAngle - startAngle;
  if (isClockwise && deltaAngle > 0) deltaAngle -= Math.PI * 2;
  if (!isClockwise && deltaAngle < 0) deltaAngle += Math.PI * 2;
  for (let i = 0; i <= segments; i++) {
    const angle = startAngle + (deltaAngle * i) / segments;
    // If Z changes, interpolate Z, else keep Z flat
    let zVal = (start.z === end.z) ? start.z : start.z + ((end.z - start.z) * i) / segments;
    points.push(new THREE.Vector3(
      center.x + radius * Math.cos(angle),
      center.y + radius * Math.sin(angle),
      zVal
    ));
  }
  return points;
}

// --- OPTIMIZED G-CODE PARSING ---
function parseGcodeOptimized(gcode) {
  const startTime = performance.now();
  
  try {
    // Parse G-code and create geometry
    const lines = gcode
      .split(/\r?\n/)
      .map(line => line.trim().replace(GCODE_REGEX.N_LINE, '')) // Remove leading N-numbers if present
      .filter(line => line.length > 0);

    let x = 0, y = 0, z = 0;
    let lastPoint = null;
    let anyDrawn = false;
    let currentMotionMode = null;
    
    // Pre-allocate arrays for better performance
    const toolpathPoints = [];
    const toolpathSegments = [];
    const toolpathModes = [];
    const lineMap = [];
    
    // Cache segment counts for animation optimization
    const segmentCounts = { G0: 0, G1: 0, G2: 0, G3: 0 };

    lines.forEach((line, idx) => {
      line = line.trim();
      
      // Find all G0/G1/G2/G3 in the line, use the last one (modal logic)
      const allModes = [...line.matchAll(GCODE_REGEX.G_MODE)];
      if (allModes.length > 0) {
        currentMotionMode = allModes[allModes.length - 1][0];
      }

      // Only skip if we have no mode and no coordinates
      const hasCoords = GCODE_REGEX.HAS_COORDS.test(line);
      if (!currentMotionMode && !hasCoords) {
        return;
      }
      
      // If still no mode, default to G1 (optional, for robustness)
      if (!currentMotionMode) {
        currentMotionMode = 'G1';
      }

      // Parse coordinates efficiently
      const matchX = line.match(GCODE_REGEX.X_COORD);
      const matchY = line.match(GCODE_REGEX.Y_COORD);
      const matchZ = line.match(GCODE_REGEX.Z_COORD);
      const matchI = line.match(GCODE_REGEX.I_OFFSET);
      const matchJ = line.match(GCODE_REGEX.J_OFFSET);
      const matchR = line.match(GCODE_REGEX.R_RADIUS);
      
      const targetX = matchX ? parseFloat(matchX[1]) : x;
      const targetY = matchY ? parseFloat(matchY[1]) : y;
      const targetZ = matchZ ? parseFloat(matchZ[1]) : z;

      if (currentMotionMode === 'G2' || currentMotionMode === 'G3') {
        // Arc move processing
        const arcStart = new THREE.Vector3(x, y, z);
        const arcEnd = new THREE.Vector3(targetX, targetY, targetZ);
        const isClockwise = currentMotionMode === 'G2';
        let arcPoints = [];

        if (matchI && matchJ) {
          const center = new THREE.Vector3(x + parseFloat(matchI[1]), y + parseFloat(matchJ[1]), z);
          if (isNaN(center.x) || isNaN(center.y) || isNaN(arcStart.x) || isNaN(arcStart.y) || isNaN(arcEnd.x) || isNaN(arcEnd.y)) {
            console.warn('Skipping arc with NaN values (I/J mode):', line);
            return;
          }
          arcPoints = interpolateArc(arcStart, arcEnd, center, isClockwise);
        } else if (matchR) {
          const dx = targetX - x;
          const dy = targetY - y;
          const d = Math.sqrt(dx * dx + dy * dy);
          const r = Math.abs(parseFloat(matchR[1]));
          if (d === 0 || isNaN(r) || r === 0) {
            console.warn('Skipping arc with invalid R or zero distance:', line);
            return;
          }
          const h = Math.sqrt(Math.max(0, r * r - (d / 2) * (d / 2)));
          const mx = (x + targetX) / 2;
          const my = (y + targetY) / 2;
          const sign = (isClockwise ? -1 : 1) * (parseFloat(matchR[1]) >= 0 ? 1 : -1);
          const cx = mx + sign * h * (dy / d);
          const cy = my - sign * h * (dx / d);
          if (isNaN(cx) || isNaN(cy)) {
            console.warn('Skipping arc with NaN center (R mode):', line);
            return;
          }
          const center = new THREE.Vector3(cx, cy, z);
          arcPoints = interpolateArc(arcStart, arcEnd, center, isClockwise);
        }

        if (arcPoints.length > 1) {
          for (let i = 1; i < arcPoints.length; i++) {
            if (isNaN(arcPoints[i - 1].x) || isNaN(arcPoints[i - 1].y) || isNaN(arcPoints[i].x) || isNaN(arcPoints[i].y)) {
              console.warn('Skipping arc segment with NaN point:', line);
              continue;
            }
            toolpathSegments.push([arcPoints[i - 1].clone(), arcPoints[i].clone()]);
            toolpathModes.push(currentMotionMode);
            lineMap.push(idx);
            segmentCounts[currentMotionMode]++;
            anyDrawn = true;
          }
          lastPoint = arcPoints[arcPoints.length - 1].clone();
          x = lastPoint.x; y = lastPoint.y; z = lastPoint.z;
          toolpathPoints.push(lastPoint.clone());
          return;
        }
      } else {
        // Linear move processing
        if (matchX) x = parseFloat(matchX[1]);
        if (matchY) y = parseFloat(matchY[1]);
        if (matchZ) z = parseFloat(matchZ[1]);
        
        const pt = new THREE.Vector3(x, y, z);
        toolpathPoints.push(pt.clone());
        
        if (lastPoint) {
          if (lastPoint.x !== pt.x || lastPoint.y !== pt.y || lastPoint.z !== pt.z) {
            toolpathSegments.push([lastPoint.clone(), pt.clone()]);
            toolpathModes.push(currentMotionMode);
            lineMap.push(idx);
            segmentCounts[currentMotionMode]++;
            anyDrawn = true;
          } else {
            return;
          }
        }
        lastPoint = pt;
      }
    });

    // Store results in global variables
    window.gcodeToolpathPoints = toolpathPoints;
    window.gcodeToolpathSegments = toolpathSegments;
    window.gcodeToolpathModes = toolpathModes;
    window.gcodeLineMap = lineMap;
    window.gcodeLines = gcode.split(/\r?\n/);
    window.gcodeSegmentCounts = segmentCounts;

    // Update performance stats
    performanceStats.parseTime = performance.now() - startTime;
    performanceStats.segmentCount = toolpathSegments.length;
    performanceStats.lineCount = lines.length;

    return { anyDrawn, toolpathPoints, toolpathSegments, toolpathModes, lineMap, segmentCounts };
    
  } catch (error) {
    console.error('Error parsing G-code:', error);
    showError(`G-code parsing error: ${error.message}`);
    return { anyDrawn: false };
  }
}

function showGcodeViewer() {
  if (domElements.gcodeViewerModal) {
    domElements.gcodeViewerModal.style.display = 'flex';
  }
  showLoadingIndicator(true);
  
  try {
    if (window.outputEditor && typeof window.outputEditor.getValue === 'function') {
      const val = window.outputEditor.getValue();
      renderGcode3D(val);
    } else {
      renderGcode3D('');
    }
  } catch (error) {
    console.error('Error showing G-code viewer:', error);
    showError(`Failed to load G-code viewer: ${error.message}`);
  } finally {
    showLoadingIndicator(false);
  }
}

function closeGcodeViewer() {
  if (domElements.gcodeViewerModal) {
    domElements.gcodeViewerModal.style.display = 'none';
  }
  
  try {
    // Clean up Three.js renderer
    if (domElements.gcode3d) {
      domElements.gcode3d.innerHTML = '';
    }
    
    // Stop any running animation
    if (window.gcodeSimAnimationId) {
      clearTimeout(window.gcodeSimAnimationId);
      window.gcodeSimAnimationId = null;
    }
    
    // Invalidate any running simulation loop
    if (window.gcodeSimGeneration) window.gcodeSimGeneration++;
    
    // Reset simState
    simState.stopped = true;
    simState.paused = false;
    simState.playing = false;
    simState.idx = 0;
    
    // Reset progress bar if present
    updateProgressBar(0);
    
    // Clear global variables to prevent memory leaks
    window.gcodeToolpathPoints = null;
    window.gcodeToolpathSegments = null;
    window.gcodeToolpathModes = null;
    window.gcodeLineMap = null;
    window.gcodeLines = null;
    window.gcodeSegmentCounts = null;
    window.gcodeScene = null;
    window.gcodeCamera = null;
    window.gcodeToolMesh = null;
    window.gcodeRender = null;
    
    // Clear line info
    clearGcodeLineInfo();
    
    // Reset performance stats
    performanceStats = {
      parseTime: 0,
      renderTime: 0,
      segmentCount: 0,
      lineCount: 0
    };
    
  } catch (error) {
    console.error('Error closing G-code viewer:', error);
  }
}

function renderGcode3D(gcode) {
  const startTime = performance.now();
  if (!domElements.gcode3d) {
    console.error('G-code 3D container not found');
    return;
  }
  domElements.gcode3d.innerHTML = '';
  
  try {
    // Dispose of old geometries/materials if present
    disposeOldGeometries();

  // Setup Three.js scene
  const scene = new THREE.Scene();
  scene.background = null; // transparent
  const camera = new THREE.PerspectiveCamera(60, domElements.gcode3d.offsetWidth / domElements.gcode3d.offsetHeight, 0.1, 50000);
  camera.position.set(0, -100, 80);
  camera.up.set(0, 0, 1); // Z is up to prevent twist

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setClearColor(0x000000, 0); // 0 alpha for full transparency
  // Lower pixel ratio for large jobs
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(domElements.gcode3d.offsetWidth, domElements.gcode3d.offsetHeight);
  domElements.gcode3d.appendChild(renderer.domElement);

  // WebGL context loss handler
  renderer.domElement.addEventListener('webglcontextlost', function(e) {
    alert('WebGL context lost. Please reload the page.');
    e.preventDefault();
  }, false);

  // Add light
  const light = new THREE.DirectionalLight(0xffffff, 0.7);
  light.position.set(0, 0, 100);
  scene.add(light);

  // Parse G-code and create geometry
  const { anyDrawn, toolpathPoints, toolpathSegments, toolpathModes, lineMap, segmentCounts } = parseGcodeOptimized(gcode);

  if (!anyDrawn) {
    // Show message if not enough points
    const msg = document.createElement('div');
    msg.style.color = '#fff';
    msg.style.position = 'absolute';
    msg.style.top = '50%';
    msg.style.left = '50%';
    msg.style.transform = 'translate(-50%,-50%)';
    msg.style.fontSize = '1.5em';
    msg.textContent = 'No G0/G1 toolpaths found in output!';
    domElements.gcode3d.appendChild(msg);
    return;
  }

  // Add axes helper
  scene.add(new THREE.AxesHelper(10));

  // OrbitControls
  let controls;
  controls = setupOrbitControls(camera, renderer, render);

  // Responsive resize
  function onResize() {
    const w = domElements.gcode3d.offsetWidth, h = domElements.gcode3d.offsetHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    render();
  }
  window.addEventListener('resize', onResize);

  // Efficient render function
  function render() {
    renderer.render(scene, camera);
  }
  window.gcodeRender = render;
  // Replace animate() with a single render call
  render();
  // Optimized point array creation - single pass through segments
  const g0Points = [], g1Points = [], g2Points = [], g3Points = [];
  const segments = window.gcodeToolpathSegments;
  const modes = window.gcodeToolpathModes;
  
  for (let i = 0; i < segments.length; ++i) {
    const seg = segments[i];
    const mode = modes[i];
    if (mode === 'G0') g0Points.push(seg[0], seg[1]);
    else if (mode === 'G1') g1Points.push(seg[0], seg[1]);
    else if (mode === 'G2') g2Points.push(seg[0], seg[1]);
    else if (mode === 'G3') g3Points.push(seg[0], seg[1]);
  }

  // Create BufferGeometry for each mode
  createLineObjects(scene, g0Points, g1Points, g2Points, g3Points);
  // Show full path if requested
  if (g0Points.length === 0 && g1Points.length === 0 && g2Points.length === 0 && g3Points.length === 0) {
    const msg = document.createElement('div');
    msg.style.color = '#fff';
    msg.style.position = 'absolute';
    msg.style.top = '50%';
    msg.style.left = '50%';
    msg.style.transform = 'translate(-50%,-50%)';
    msg.style.fontSize = '1.5em';
    msg.textContent = 'No G0/G1/G2/G3 toolpaths found in output!';
    domElements.gcode3d.appendChild(msg);
    return;
  }

  // Store scene and camera for simulation
  window.gcodeScene = scene;
  window.gcodeCamera = camera;

  // After creating batched lines and toolpath segments, show full path by default
  // Show all lines
  updateAllDrawRanges(
    window.gcodeBatchedCounts.G1 / 2,
    window.gcodeBatchedCounts.G0 / 2,
    window.gcodeBatchedCounts.G2 / 2,
    window.gcodeBatchedCounts.G3 / 2
  );
  // After parsing toolpath and before adding toolhead, compute bounding box
  let bbox = null;
  if (window.gcodeToolpathPoints && window.gcodeToolpathPoints.length > 0) {
    bbox = new THREE.Box3().setFromPoints(window.gcodeToolpathPoints);
  }









  // Create toolhead as a white downward ArrowHelper
  let arrowPos = new THREE.Vector3(0, 0, 0);
  if (window.gcodeToolpathSegments && window.gcodeToolpathSegments.length > 0) {
    // Use last segment for position
    const lastSeg = window.gcodeToolpathSegments[window.gcodeToolpathSegments.length-1];
    arrowPos = lastSeg[1];
  }
  const tool = createToolArrow(scene, arrowPos);
  window.gcodeToolMesh = tool;

  // Move toolhead to end position
  if (window.gcodeToolpathSegments && window.gcodeToolpathSegments.length > 0) {
    const lastSeg = window.gcodeToolpathSegments[window.gcodeToolpathSegments.length-1];
    updateToolPosition(window.gcodeToolMesh, lastSeg[1]);
  }
  // Auto-center camera and controls on toolpath
  if (bbox) {
    const center = bbox.getCenter(new THREE.Vector3());
    const size = bbox.getSize(new THREE.Vector3());
    // Place camera back far enough to see the whole path
    const maxDim = Math.max(size.x, size.y, size.z);
    camera.position.set(center.x, center.y - maxDim * 1.5, center.z + maxDim * 0.8);
    camera.lookAt(center);
    if (controls) {
      controls.target.copy(center);
      controls.update();
    }
  }
  // Set progress bar to end
  if (domElements.progressBar && window.gcodeToolpathSegments) {
    domElements.progressBar.value = window.gcodeToolpathSegments.length;
  }
  // Set state to stopped, idx to end
  simState.stopped = true;
  simState.paused = false;
  simState.playing = false;
  simState.idx = window.gcodeToolpathSegments ? window.gcodeToolpathSegments.length : 0;
  window.gcodeRender && window.gcodeRender();
  
  // Update performance stats
  performanceStats.renderTime = performance.now() - startTime;
  console.log(`G-code rendering completed in ${performanceStats.renderTime.toFixed(2)}ms`);
  console.log(`Parsed ${performanceStats.lineCount} lines into ${performanceStats.segmentCount} segments`);
  
  // Show performance stats
  showPerformanceStats();
  
  } catch (error) {
    console.error('Error rendering G-code:', error);
    showError(`G-code rendering error: ${error.message}`);
  }
}

function runSimulation(targetIdx, preserveDrawn) {
  // --- Simulation generation control ---
  if (!window.gcodeSimGeneration) window.gcodeSimGeneration = 1;
  else window.gcodeSimGeneration++;
  const thisGeneration = window.gcodeSimGeneration;
  // Stop any previous animation
  if (window.gcodeSimAnimationId) {
    clearTimeout(window.gcodeSimAnimationId);
    window.gcodeSimAnimationId = null;
  }
  const points = window.gcodeToolpathPoints;
  const segments = window.gcodeToolpathSegments;
  const modes = window.gcodeToolpathModes;
  const scene = window.gcodeScene;
  if (!points || points.length === 0 || !scene || !segments || segments.length === 0) return;
  // Remove previous tool if any
  if (window.gcodeToolMesh) {
    if (window.gcodeScene && window.gcodeToolMesh.parent === window.gcodeScene) {
      window.gcodeScene.remove(window.gcodeToolMesh);
    }
    window.gcodeToolMesh = null;
  }
  // Optimized draw range calculation using cached segment counts
  function calculateDrawRanges(upto) {
    let g1Segs = 0, g0Segs = 0, g2Segs = 0, g3Segs = 0;
    for (let i = 0; i < upto; ++i) {
      if (modes[i] === 'G1') g1Segs++;
      else if (modes[i] === 'G0') g0Segs++;
      else if (modes[i] === 'G2') g2Segs++;
      else if (modes[i] === 'G3') g3Segs++;
    }
    return { g1Segs, g0Segs, g2Segs, g3Segs };
  }




  // Create toolhead as a white downward ArrowHelper
  let arrowPos = new THREE.Vector3(0, 0, 0);
  if (window.gcodeToolpathSegments && window.gcodeToolpathSegments.length > 0) {
    // Use last segment for position
    const lastSeg = window.gcodeToolpathSegments[window.gcodeToolpathSegments.length-1];
    arrowPos = lastSeg[1];
  }
  const tool = createToolArrow(scene, arrowPos);
  window.gcodeToolMesh = tool;

  let idx = typeof targetIdx === 'number' ? targetIdx : 0;
  simState.idx = idx;
  simState.stopped = false;
  simState.paused = false;
  simState.playing = true;
  // Progress bar setup
  if (domElements.progressBar) {
    domElements.progressBar.max = segments.length;
    updateProgressBar(idx);
    domElements.progressBar.oninput = function() {
    // Stop any running animation
    if (window.gcodeSimAnimationId) {
      clearTimeout(window.gcodeSimAnimationId);
      window.gcodeSimAnimationId = null;
    }
    // Save previous state
    const wasPlaying = simState.playing;
    // Always update simState.idx and visualization
    const newIdx = Number(domElements.progressBar.value);
    simState.idx = newIdx;
    // Update drawRange using optimized calculation
    const drawRanges = calculateDrawRanges(newIdx);
    updateAllDrawRanges(drawRanges.g1Segs, drawRanges.g0Segs, drawRanges.g2Segs, drawRanges.g3Segs);
    // Move toolhead to the end of the last drawn segment
    if (window.gcodeToolMesh) {
      if (newIdx > 0) {
        updateToolPosition(window.gcodeToolMesh, segments[newIdx-1][1]);
      } else {
        updateToolPosition(window.gcodeToolMesh, segments[0][0]);
      }
    }
    // Update G-code line info label
    if (window.gcodeLineMap && window.gcodeLineMap[newIdx-1] !== undefined) {
      showGcodeLineInfo(window.gcodeLineMap[newIdx-1]);
    } else {
      clearGcodeLineInfo();
    }
    // Only render
    window.gcodeRender && window.gcodeRender();
    // If was playing, immediately resume simulation from new position
    if (wasPlaying) {
      simState.playing = true;
      simState.paused = false;
      simState.stopped = false;
      setTimeout(() => runSimulation(newIdx, true), 0);
    } else {
      simState.playing = false;
    }
  };
  }
  // Speed slider setup
  let speed = Math.max(0.001, Number(domElements.speedSlider?.value || 10));
  
  function updateSpeedLabel() {
    if (domElements.speedValue) {
      domElements.speedValue.textContent = speed;
    }
    if (domElements.speedUnit) {
      if (speed > 1) {
        domElements.speedUnit.textContent = 'ms/step';
      } else {
        domElements.speedUnit.textContent = 'seg/tick';
      }
    }
  }
  
  updateSpeedLabel();
  
  if (domElements.speedSlider) {
    domElements.speedSlider.oninput = function() {
      speed = Math.max(0.001, Number(domElements.speedSlider.value));
      updateSpeedLabel();
    };
  }
  function animateTool() {
    // Only allow the latest simulation loop to run
    if (thisGeneration !== window.gcodeSimGeneration) return;
    if (!window.gcodeToolMesh || simState.stopped) return; // Stop if tool was removed or stopped
    if (simState.paused) return; // Pause if requested
    if (idx < segments.length) {
      // Use optimized draw range calculation
      const drawRanges = calculateDrawRanges(idx);
      let segmentsThisTick = speed > 1 ? 1 : Math.max(1, Math.round(1 / speed));
      for (let s = 0; s < segmentsThisTick && idx < segments.length; ++s) {
        updateToolPosition(window.gcodeToolMesh, segments[idx][0]);
        // Show current G-code line info
        if (window.gcodeLineMap && window.gcodeLineMap[idx] !== undefined) {
          showGcodeLineInfo(window.gcodeLineMap[idx]);
        }
        idx++;
        simState.idx = idx;
        updateProgressBar(idx);
      }
      updateAllDrawRanges(drawRanges.g1Segs, drawRanges.g0Segs, drawRanges.g2Segs, drawRanges.g3Segs);
      window.gcodeRender && window.gcodeRender(); // Only render when something changes
      if (idx < segments.length)
        window.gcodeSimAnimationId = setTimeout(animateTool, speed > 1 ? speed : 1);
      else {
        simState.playing = false;
        simState.paused = false;
        simState.stopped = true;
        clearGcodeLineInfo();
        if (typeof updatePlayPauseIcon === 'function') updatePlayPauseIcon();
        // Ensure everything is fully displayed at the end
        if (window.gcodeToolMesh && segments.length > 0)
          updateToolPosition(window.gcodeToolMesh, segments[segments.length-1][1]);
        updateAllDrawRanges(
          window.gcodeBatchedCounts.G1 / 2,
          window.gcodeBatchedCounts.G0 / 2,
          window.gcodeBatchedCounts.G2 / 2,
          window.gcodeBatchedCounts.G3 / 2
        );
        if (window.gcodeLineMap && window.gcodeLineMap[segments.length-1] !== undefined)
          showGcodeLineInfo(window.gcodeLineMap[segments.length-1]);
        updateProgressBar(segments.length);
        window.gcodeRender && window.gcodeRender();
      }
    }
    else {
      simState.playing = false;
      simState.paused = false;
      simState.stopped = true;
      clearGcodeLineInfo();
      if (typeof updatePlayPauseIcon === 'function') updatePlayPauseIcon();
      // Optionally remove tool after simulation
      // scene.remove(tool);
      // window.gcodeToolMesh = null;
    }
  }
  animateTool();
}

function updatePlayPauseIcon() {
  if (!domElements.playBtn || !domElements.runSimulationIcon) return;
  
  if (simState.playing) {
    domElements.playBtn.classList.remove('sim-play');
    domElements.playBtn.classList.add('sim-pause');
    domElements.runSimulationIcon.innerHTML = pauseIcon;
    domElements.playBtn.title = 'Pause';
  } else {
    domElements.playBtn.classList.remove('sim-pause');
    domElements.playBtn.classList.add('sim-play');
    domElements.runSimulationIcon.innerHTML = playIcon;
    domElements.playBtn.title = 'Play';
  }
}

function showGcodeLineInfo(lineIdx) {
  if (!domElements.gcodeLineInfo) return;
  if (!window.gcodeLines || !window.gcodeLines[lineIdx]) return;
  domElements.gcodeLineInfo.style.display = '';
  domElements.gcodeLineInfo.textContent = `G-code line ${lineIdx + 1}: ${window.gcodeLines[lineIdx]}`;
  // Select and reveal the line in the output editor
  if (window.outputEditor && typeof lineIdx === 'number') {
    window.outputEditor.revealLineInCenter(lineIdx + 1);
    window.outputEditor.setSelection(
      new monaco.Range(lineIdx + 1, 1, lineIdx + 1, 1)
    );
  }
}

function clearGcodeLineInfo() {
  if (domElements.gcodeLineInfo) {
    domElements.gcodeLineInfo.style.display = 'none';
    domElements.gcodeLineInfo.textContent = '';
  }
}





document.addEventListener('DOMContentLoaded', function() {
  // Cache DOM elements
  cacheDOMElements();
  
  // Add keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    // Ctrl+Shift+P to show performance stats
    if (e.ctrlKey && e.shiftKey && e.key === 'P') {
      e.preventDefault();
      showPerformanceStats();
    }
  });
  
  // --- EVENT HANDLERS ---
  if (domElements.playBtn) {
    domElements.playBtn.onclick = function() {
      const segments = window.gcodeToolpathSegments;
      if (simState.playing) {
        // Pause
        simState.paused = true;
        simState.playing = false;
        simState.stopped = false;
        updatePlayPauseIcon();
      } else {
        // Play/resume or restart if at end
        if (segments && simState.idx >= segments.length) {
          runSimulation(0, false);
          simState.playing = true;
          simState.paused = false;
          simState.stopped = false;
          updatePlayPauseIcon();
          return;
        }
        if (simState.stopped) {
          runSimulation(simState.idx || 0, true);
        } else if (simState.paused) {
          runSimulation(simState.idx, true);
        }
        simState.playing = true;
        simState.paused = false;
        simState.stopped = false;
        updatePlayPauseIcon();
      }
    };
  }
  
  if (domElements.rewindBtn) {
    domElements.rewindBtn.onclick = function() {
      // True rewind: no lines drawn, toolhead at start, progress bar at 0, stopped
      const segments = window.gcodeToolpathSegments;
      const points = window.gcodeToolpathPoints;
      updateAllDrawRanges(0, 0, 0, 0); // Reset all draw ranges
      if (window.gcodeToolMesh && points && points.length > 0) {
        updateToolPosition(window.gcodeToolMesh, points[0]);
      }
      updateProgressBar(0);
      simState.stopped = true;
      simState.paused = false;
      simState.playing = false;
      simState.idx = 0;
      window.gcodeRender && window.gcodeRender();
      updatePlayPauseIcon();
      clearGcodeLineInfo();
    };
  }
  
  if (domElements.forwardBtn) {
    domElements.forwardBtn.onclick = function() {
      // Jump to end
      const segments = window.gcodeToolpathSegments;
      if (!segments || segments.length === 0) return;
      simState.stopped = true;
      simState.paused = false;
      simState.playing = false;
      runSimulation(segments.length, false);
      simState.idx = segments.length;
      // Show full path
      updateAllDrawRanges(
        window.gcodeBatchedCounts.G1 / 2,
        window.gcodeBatchedCounts.G0 / 2,
        window.gcodeBatchedCounts.G2 / 2,
        window.gcodeBatchedCounts.G3 / 2
      );
      // Move toolhead to end
      if (window.gcodeToolMesh && segments.length > 0) {
        updateToolPosition(window.gcodeToolMesh, segments[segments.length-1][1]);
      }
      // Update progress bar
      updateProgressBar(segments.length);
      window.gcodeRender && window.gcodeRender();
      updatePlayPauseIcon();
    };
  }
  
  // Update icon on state changes
  updatePlayPauseIcon();
  
  // Speed slider label update (fallback for direct access)
  if (domElements.speedSlider && domElements.speedValue) {
    domElements.speedSlider.oninput = function() {
      domElements.speedValue.textContent = domElements.speedSlider.value;
    };
  }
  
  // Load G-code from URL parameter if present
  const urlParams = new URLSearchParams(window.location.search);
  const gcodeParam = urlParams.get('gcode');
  if (gcodeParam) {
    const decodedGcode = decodeURIComponent(gcodeParam);
    showGcodeViewer();
    renderGcode3D(decodedGcode);
  }
});
</script>